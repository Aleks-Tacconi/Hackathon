Chapter 2
Numbers and computers
First we consider: how can we represent numbers inside a computer?
2.1 Using bases
Our number systems tend to be positional with respect to some base. Normally the base
10 system is used, so 137 represents
1 × 102 + 3 × 101 + 7 × 100
Using base 10 representions in computers is not common, although not impossible. The
19th century computer designed by Charles Babbage had columns of cog wheels, with the
digits 0 to 9 etched on them. Then each column contains a number represented using the
decimal interpretation, each cog on the column corresponding to a power of 10. You can
see a version of Babbages machine being described and operated at the following site
http://www.youtube.com/watch?v=0anIyVGeWOI
It shows the cogs and how precisely they needed to be made. Storing decimal digits can
be expensive for modern technologies.
Base 10 is not the only base that has been adopted. The Ancient Babylonians (1750
BC) used a sexadecimal system, that is base 60. This is why one hour is divided into 60
minutes and 1 minute into 60 seconds. The advantage of this system is that 60 has lots of
divisors but a disadvantage is that we need to design and remember 60 different symbols,
and the multiplication tables would be large.
Many computer languages use hexadecimal, base 16, with symbols 0,. . . ,9,A,B,C,D,E,F.
Electronic computers lend themselves to a binary, base 2, system because 0 and 1 can
be represented by ‘on’ and ‘off’. Historically this has been done via relays, vacuum tubes,
transistors and voltages on integrated circuits. You can see vacuum tube memory on the
Bletchley Park rebuild of the Colossus machine
http://en.wikipedia.org/wiki/File:ColossusRebuild_11.jpg
http://en.wikipedia.org/wiki/File:Colossus.jpg
The numbers 0 and 1 are called the binary digits, and may be referred to as bits. The
term bit was introduced by John Tukey, an American statistician and computer scientist,
in 1946. (Binary would have been much more expensive for Babbage, needing many more
cogs and columns.)
There are many methods that have been used to implement bits. In magnetic storage
devices (Hard Rigid Disk, Floppy, Zip, Tape, etc.) magnetized areas of the media are
used to represent binary numbers: a magnetized area stands for 1, and the absence of
magnetization means 0. Flip-flops are electronic devices that can only carry two distinct
6 NUMBERS AND COMPUTERS
voltages at their outputs, traditionally 0 and 5 volts. They can be switched from one state
to the other state by an impulse. Optical and magneto-optical storage devices use two
distinct levels of light reflectance or polarization to represent 0 or 1.
The ideas and results covered in this course apply to all methods of representing bits,
we abstract away from the hardware details.
2.2 Binary numbers
2.2.1 Positional representations
Recall that decimal numbers are written positionly, using coefficients of powers of 10.
137 = (1 × 100) + (3 × 10) + (1 × 7)
Similarly, binary numbers are sequences of 0s and 1s, interpreted as coefficients of
powers of 2, with the highest power to the left.
11010 = (1 × 2
4
) + (1 × 2
3
) + (0 × 2
2
) + (1 × 2
1
) + (0 × 2
0
) = 26
It is usually easiest when converting long binary numbers to decimal number to start
from the right rather than the left.
11010 = (0 × 2
0
) + (1 × 2
3
) + (0 × 2
2
) + (1 × 2
3
) + (1 × 2
4
) = 26
The value of the expression is the same, the left-most binary digit still corresponds to the
highest power of 2, we have just written the powers out in the opposite order.
Of course decimal 11 (that is base 10) is a different value to binary 11 (base 2), which
is decimal 3. So it is important to know the base. If there is any possibility of confusion
we write the base as a subscript. So 112 is binary 11, which has decimal value 3.
We carry this notation over to equality statements, so we write
112 = 3 or even 112 = 310
and 110102 = 2610 (or 110102 = 26, since 10 is the default base).
Another example:
11101 = (1 × 2
4
) + (1 × 2
3
) + (1 × 2
2
) + (0 × 2
1
) + (1 × 2
0
) = 29
111012 = 29 or 111012 = 2910
Exercise 2.1
Write (i) 100102 and (ii) 1100102 in decimal form.
Here are the first 32 binary integers.
0: 0 8: 1000 16: 10000 24: 11000
1: 1 9: 1001 17: 10001 25: 11001
2: 10 10: 1010 18: 10010 26: 11010
3: 11 11: 1011 19: 10011 27: 11011
4: 100 12: 1100 20: 10100 28: 11100
5: 101 13: 1101 21: 10101 29: 11101
6: 110 14: 1110 22: 10110 30: 11110
7: 111 15: 1111 23: 10111 31: 11111
Binary numbers 7
2.2.2 Padding with leading zeros
It does make sense to write decimal numbers in the form, say, 004502, with zeros to the
left. However, this is rarely done. There are some exceptions though, 007 is very well
known and hotel rooms are sometimes number 01, 02 etc, if they are on the ground floor.
The opposite is true for binary numbers. When used in hardware, binary integers tend
all to have the same length, achieved by packing with zeros from the left.
0: 00000 8: 01000 16: 10000 24: 11000
1: 00001 9: 01001 17: 10001 25: 11001
2: 00010 10: 01010 18: 10010 26: 11010
3: 00011 11: 01011 19: 10011 27: 11011
4: 00100 12: 01100 20: 10100 28: 11100
5: 00101 13: 01101 21: 10101 29: 11101
6: 00110 14: 01110 22: 10110 30: 11110
7: 00111 15: 01111 23: 10111 31: 11111
Notice, even numbers end with 0 (on the right), odd numbers end with 1.
2.2.3 Finding binary representations
Given a binary number we can find the equivalent decimal representation by adding together the corresponding powers of 2.
Similarly, given a decimal number we can find the equivalent binary representation by
subtracting powers of 2.
Start by finding the highest power of 2 which is less than or equal to the binary number.
Then subtract this power of 2 from the number to get the remainder. For example, we
convert 13710 to binary as follows.
2
7 = 128 < 137 < 256 = 28
remainder 137 − 128 = 9
Repeat this process on the remainder,
2
3 = 8 < 9 < 16 = 24
remainder 9 − 8 = 1 = 20
Carry on in this way until the remainder is a power of 2.
137 = 128 + 9 = 128 + 8 + 1
= (1 × 128) + (0 × 64) + (0 × 32) + (0 × 16) + (1 × 8) + (0 × 4) + (0 × 2) + (1 × 1)
= 100010012
Another example:
1000 = 512 + 488 = 512 + 256 + 232 = 512 + 256 + 128 + 104
= 512 + 256 + 128 + 64 + 40 = 512 + 256 + 128 + 64 + 32 + 8
= 11111010002
Exercise 2.2
Write (i) 97 and (ii) 232 in binary form.
8 NUMBERS AND COMPUTERS
2.2.4 Using binary numbers - counting
Binary numbers can be used like decimal ones.
 Counting in decimal:
0, 1, 2,. . . , 9, 10, 11,. . . , 19, 20, 21,. . . , 99, 100, 101,. . .
 Counting in binary:
0, 1, 10, 11, 100, 101, 110, 111, 1000, 1001, 1010, 1011, 1100,. . .
In both cases it is the same rule: as a digit reaches its maximum allowable value, it
becomes 0, and the digit to its left is incremented by 1 (recursively).
Exercise 2.3
Write down the next four numbers in the binary series.
2.2.5 Using binary numbers - arithmetic
Binary numbers add and multiply together in the same way as decimal numbers. We have
2
0 + 20 = 1 + 1 = 21
so 12 + 12 = 102
3 = 2 + 1 = 21 + 20
so 102 + 12 = 112
5 = 2 + 3 = 21 + 21 + 20
so 102 + 112 = 1012
In general we add and multiply binary numbers using position and carry from the left, as
for decimal numbers.
101
------
1000110 1111001 1011 101 | 11001
+ 110011 - 110011 x 101 -101
------- ------- ---- ---
1111001 1000110 1011 101
101100 -101
------ ---
110111 0
The following are the addition and multiplication table for the binary digits.
Addition table:
+ 0 1
0 0 1
1 1 10
Multiplication table:
× 0 1
0 0 0
1 0 1
Exercises 2.4
Carry out the following operations:
(i) 101110012 + 110011012
(ii) 110111002 − 11101112
(iii) 11102 × 11012
(iv) 1110012/1012 (with remainder)